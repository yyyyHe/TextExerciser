# -*- coding: utf-8 -*-
import re, random
import func_timeout
from func_timeout import func_set_timeout
import string as template_string
from src import globalConfig
from z3 import *

NONE_PRINTABLE = ['\x00', '\x01', '\x02', '\x03']


class Composition:

    def __init__(self):
        global logger
        logger = globalConfig.te_logger
        self.compose = {
            # Constraint composition
            'Number': (False, template_string.digits, 0),
            'Letter': (False, template_string.ascii_letters, 0),
            'Special': (False, template_string.punctuation, 0),
            'Space': (False, ' ', 0),
            'maxlength': 9999,
            'minlength': 0,
            'maxval': 9999,
            'minval': 0
        }
        # constraint type: time(date)、str、value、repeat、invalid
        self.type = 'Null'
        self.ordHelperCounter = 0
        if globalConfig.UsingZ3:
            self.z3solver = Solver()
        else:
            self.z3solver = None

        try:
            self.reset_solver()
        except Exception as e:
            print(e)
            logger.warn('z3 initialize failed')
            self.z3solver = None

    def reset_solver(self):
        """
        Initial z3 solver. Exclude none-printable characters.
           Set length between 1 and 999.
        """
        if self.z3solver is None:
            return
        self.z3solver.reset()
        initial_str = String('x')
        initial_value = Int('y')
        # Z3 generate from 256 ascii-characters. But only printable characters are what we need.
        for i in range(0, 200):
            hex_str = str(hex(i))[2:].zfill(2)
            target_bytes = bytes.fromhex(hex_str)
            if i >= 128 or target_bytes.decode(
                    'utf-8') not in template_string.ascii_letters + template_string.digits + template_string.punctuation:
                self.z3solver.add(Not(Contains(initial_str, StringVal(target_bytes))))
        self.__contain('Total', 1)
        # Min and max length of our input set in a big scope.
        self.z3solver.add(And(Length(initial_str) > 0, Length(initial_str) < 9999))
        self.z3solver.add(And(initial_value > 0, initial_value < 999))

    def solve(self, target='string'):
        """
        use z3 string solver to solve constraint.
        """
        result_str = ''
        result_value = -1
        is_need_deal = True
        limit = 10
        if self.z3solver is None:
            return result_str, result_value
        try:
            logger.info('Try z3 solver')
            while limit > 0:
                limit -= 1
                if self.__is_solvable():
                    if target == 'string':
                        x = String('x')
                        result_str = self.z3solver.model()[x].as_string()
                        if not self.__is_valid(result_str):
                            logger.warn('[Try]z3 solution invalid --> ' + result_str)
                            self.exclude_history([result_str])
                            continue
                        logger.info('Choose valid solution : ' + result_str)
                        is_need_deal = False
                    else:
                        y = Int('y')
                        result_value = int(self.z3solver.model()[y].as_string())
                        logger.info('Choose valid solution : %d' % result_value)
                    break
            else:
                result_value = -1
        except func_timeout.exceptions.FunctionTimedOut:
            logger.error('z3 solver run out of time')
            result_value = -1
        except Exception as e:
            print(e)
        if is_need_deal and result_str:
            result_str = self.deal_invalid_str(result_str)
        return result_str, result_value

    @staticmethod
    def deal_invalid_str(result_str):
        """
        replace invalid char
        """
        tag = 'SSR'
        result_str = re.sub(r'\\x[a-f\d][a-f\d]', tag, result_str)
        common_str = result_str.replace(tag, '')
        common_str = common_str[-1] if common_str else ''
        result_str = result_str.replace(tag, common_str)
        return result_str

    @func_set_timeout(30)
    def __is_solvable(self):
        try:
            if self.z3solver.check() == sat:
                logger.info('z3 has solution')
                return True
            else:
                logger.info('could not solve z3 constraint')
                return False
        except Exception as e:
            print(e)
            logger.error('z3 error')
        return False

    def __is_valid(self, string):
        """
        If The value generated by z3 is printable, return True.
        """
        for char in string:
            if char not in template_string.printable:
                return False
        pattern = r'\\x[a-f\d][a-f\d]'
        if re.findall(pattern, string):
            return False
        else:
            return True

    @staticmethod
    def get_content_labels():
        return {'Letter', 'Number', 'Special', 'Space'}

    def convert_content_constraint(self, mutate_label, mutate_content, is_expected=True):
        """
        convert constraint to rule
        :param mutate_label: mutate label like Special
        :param mutate_content: constraint content like @，！
        :param is_expected: contain or not
        :return: None
        """
        if is_expected:
            if mutate_label != 'Null':
                if mutate_label == 'UpperCase':
                    self.compose['Letter'] = (True, template_string.ascii_uppercase, self.compose['Letter'][2])
                    self.__contain('UpperCase', 1)
                elif mutate_label == 'LowerCase':
                    self.compose['Letter'] = (True, template_string.ascii_lowercase, self.compose['Letter'][2])
                    self.__contain('LowerCase', 1)
                elif mutate_label == 'Number' or mutate_label == 'Letter' or mutate_label == 'Space':
                    self.compose[mutate_label] = (True, self.compose[mutate_label][1], self.compose[mutate_label][2])
                    self.__contain(mutate_label, 1)
                elif mutate_label == 'Special':
                    if re.findall('underscore|_', mutate_content):
                        # composition[format] = (True, '_',composition['Special'][2])
                        self.__contain('_', 1)
                        self.compose[mutate_label] = (True, '_', 1)
                    elif re.findall('dash|-', mutate_content):
                        self.__contain('-', 1)
                        # composition[format] = (True, '-',composition['Special'][2])
                        self.compose[mutate_label] = (True, '-', 1)
                    elif re.findall('point|\.', mutate_content):
                        self.__contain('.', 1)
                        # composition[format] = (True, '.',composition['Special'][2])
                        self.compose[mutate_label] = (True, '.', 1)
                    elif re.findall('@', mutate_content):
                        self.__contain('@', 1)
                        # composition[format] = (True, '@', composition['Special'][2])
                        self.compose[mutate_label] = (True, '@', 1)
                    else:
                        self.__contain(template_string.punctuation, 1)
                        self.compose[mutate_label] = (True, '!@#$%^&.*()_+=-', self.compose[mutate_label][2])
                else:
                    logger.error('Unknown format in ContentConstraint--' + mutate_label)
        else:
            # Should not include this format in compose.
            if mutate_label != 'Null':
                if mutate_label == 'UpperCase':
                    self.compose['Letter'] = (True, template_string.ascii_lowercase, self.compose['Letter'][2])
                    self.__contain('UpperCase', 2)
                elif mutate_label == 'LowerCase':
                    self.compose['Letter'] = (True, template_string.ascii_uppercase, self.compose['Letter'][2])
                    self.__contain('LowerCase', 2)
                elif mutate_label == 'Number' or mutate_label == 'Letter' or mutate_label == 'Space':
                    self.compose[mutate_label] = (True, '', 0)
                    self.__contain(mutate_label, 2)
                elif mutate_label == 'Special':
                    # check special characters.
                    if re.findall('underscore|_', mutate_content):
                        self.compose[mutate_label] = (
                            True, self.compose['Special'][1].replace('_', ''), self.compose['Special'][2])
                        self.__contain('_', 2)
                    elif re.findall('dash|-', mutate_content):
                        self.compose[mutate_label] = (
                            True, self.compose['Special'][1].replace('-', ''), self.compose['Special'][2])
                        self.__contain('-', 2)
                    elif re.findall('point|\.', mutate_content):
                        self.compose[mutate_label] = (
                            True, self.compose['Special'][1].replace('.', ''), self.compose['Special'][2])
                        self.__contain('.', 2)
                    elif re.findall('@', mutate_content):
                        self.compose[mutate_label] = (
                            True, self.compose['Special'][1].replace('@', ''), self.compose['Special'][2])
                        self.__contain('@', 2)
                    else:
                        self.compose[mutate_label] = (True, '', 0)
                        self.__contain('Special', 2)
                else:
                    logger.error('Unknown format in ContentConstraint--' + mutate_label)

    def convert_length_constraint(self, mutate_label, minimal, maximum):
        """
        convert length constraint
        :param mutate_label: mutate label
        :param minimal: min length
        :param maximum: max length
        :return: None
        """
        if minimal > 0:
            if mutate_label == '' or minimal > self.compose['minlength']:
                self.compose['minlength'] = minimal
                self.__longer(minimal)
            if mutate_label != 'Null' and mutate_label != '':
                if mutate_label == 'Letter' or mutate_label == 'UpperCase' or mutate_label == 'LowerCase':
                    mutate_label = 'Letter'
                if minimal > self.compose[mutate_label][2]:
                    self.compose[mutate_label] = (self.compose[mutate_label][0], self.compose[mutate_label][1], minimal)
                    self.__contain(mutate_label, 1, minimal)
        if 0 < maximum < 9999:
            if mutate_label == '' or maximum < self.compose['maxlength']:
                self.compose['maxlength'] = maximum
                self.__shorter(maximum)

    def convert_value_constraint(self, minimal, maximum, type='Null'):
        """
        convert value constraint
        :param minimal: min
        :param maximum: max
        :param type: mutate type
        :return: None
        """
        if type != 'Null':
            self.type = type
        if minimal > 0:
            if self.compose['minval'] < minimal:
                self.compose['minval'] = minimal
                self.__bigger(minimal)
        if 0 < maximum < 9999:
            if self.compose['maxval'] > maximum:
                self.compose['maxval'] = maximum
                self.__smaller(maximum)
        if self.compose['minval'] > self.compose['maxval']:
            self.compose['maxval'] = self.compose['minval'] + 1
            self.__smaller(self.compose['minval'] + 1)
            logger.warn('Z3 could not roll back')

    def check_compose(self, string, key, prob):
        """
        adjust the prob composition
        """
        realm = {
            'Number': template_string.digits,
            'Letter': template_string.ascii_letters,
            'Special': template_string.punctuation,
            'Space': " "
        }
        if self.compose[key][0]:
            stringRealm = re.findall(r'[' + realm[key] + ']', string)
            uniqeRealm = set(stringRealm)
            if self.compose[key][1]:
                composeRealm = set(list(self.compose[key][1]))
            else:
                composeRealm = set()
            if composeRealm and composeRealm > uniqeRealm:
                if self.compose[key][2] == 0:
                    if len(stringRealm) == 0:
                        if len(string) < self.compose['minlength']:
                            prob['add'] = [1, composeRealm,
                                           random.choice(range(1, 1 + self.compose['minlength'] - len(string)))]
                            prob['sub'] = [0, None, 0]
                            prob['replace'] = [0, None, None]
                            return True
                        elif len(string) > self.compose['minlength']:
                            sublen = len(string)
                            if self.compose['Letter'][0] and len(self.compose['Letter'][1]) > 0:
                                sublen -= max(self.compose['Letter'][2], 1)
                            if self.compose['Number'][0] and len(self.compose['Number'][1]) > 0:
                                sublen -= max(self.compose['Number'][2], 1)
                            if self.compose['Special'][0] and len(self.compose['Special'][1]) > 0:
                                sublen -= max(self.compose['Special'][2], 1)
                            sublen -= self.compose['Space'][2]
                            if sublen == len(string):
                                sublen = random.choice(range(0, len(string)))
                            targetRealm = set(string)
                            prob['add'] = [0, None, 0]
                            prob['sub'] = [0, None, 0]
                            prob['replace'] = [1, targetRealm, composeRealm, sublen]
                            return True
                        else:
                            if len(string) < self.compose['maxlength']:
                                prob['add'] = [1, composeRealm, 1]
                                prob['sub'] = [0, None, 0]
                                prob['replace'] = [0, None, None]
                                return True
                else:
                    if len(stringRealm) > self.compose[key][2]:
                        sublen = len(stringRealm) - self.compose[key][2]
                        if len(string) > self.compose['maxlength']:
                            prob['sub'] = [1, uniqeRealm, sublen]
                            prob['add'] = [0, None, 0]
                            prob['replace'] = [0, None, None, 0]
                        else:
                            replaceRealm = ''
                            for rkey in self.compose.keys():
                                if rkey != key and rkey != "Space" and isinstance(self.compose[rkey], tuple):
                                    replaceRealm += self.compose[rkey][1]
                            replaceRealm = set(replaceRealm)
                            prob['replace'] = [1, uniqeRealm, replaceRealm, sublen]
                            prob['sub'] = [0, None, 0]
                            prob['add'] = [0, None, 0]
                        return True
                    elif len(stringRealm) < self.compose[key][2]:
                        addlen = self.compose[key][2] - len(stringRealm)
                        if len(string) < self.compose['minlength']:
                            if uniqeRealm == composeRealm:
                                prob['add'] = [1, composeRealm, addlen]
                            else:
                                prob['add'] = [1, composeRealm - uniqeRealm, addlen]
                            prob['sub'] = [0, None, 0]
                            prob['replace'] = [0, None, None, 0]
                        else:
                            targetRealm = re.sub(r'[' + self.compose[key][1] + ']', '', string)
                            targetRealm = set(targetRealm)
                            if self.compose[key][1]:
                                replaceRealm = set(self.compose[key][1])
                            else:
                                replaceRealm = ''
                                for rkey in self.compose.keys():
                                    if rkey != key and rkey != "Space" and isinstance(self.compose[rkey], tuple):
                                        replaceRealm += self.compose[rkey][1]
                                replaceRealm = set(replaceRealm)
                            if replaceRealm:
                                prob['replace'] = [1, targetRealm, replaceRealm, addlen]
                                prob['add'] = [0, None, 0]
                                prob['sub'] = [0, None, 0]
                                return True
            else:
                length = 0
                for i in uniqeRealm - composeRealm:
                    length += stringRealm.count(i)
                if len(string) > self.compose['maxlength']:
                    prob['sub'] = [1, uniqeRealm - composeRealm, length]
                    prob['add'] = [0, None, 0]
                    prob['replace'] = [0, None, None, 0]
                    return True
                else:
                    if composeRealm:
                        replaceRealm = composeRealm
                    else:
                        replaceRealm = ''
                        for rkey in self.compose.keys():
                            if rkey != key and rkey != "Space" and isinstance(self.compose[rkey], tuple):
                                replaceRealm += self.compose[rkey][1]
                        replaceRealm = set(replaceRealm)
                    if uniqeRealm > composeRealm:
                        prob['replace'] = [1, uniqeRealm - composeRealm, replaceRealm, length]
                        prob['add'] = [0, None, 0]
                        prob['sub'] = [0, None, 0]
                        return True
        return False

    def __contain(self, label, is_expected=0, length=1):
        """
        mapping constraint to z3-solver
        :param label: Letter, Digit, Special, Space
        :param is_expected: 0-must contain; 1-contain one of these; 2-not contain
        :return: None
        """
        if self.z3solver is None:
            return
        try:
            input_str = String('x')
            if label == 'Letter':
                pool = template_string.ascii_letters
            elif label == 'UpperCase':
                pool = template_string.ascii_uppercase
            elif label == 'LowerCase':
                pool = template_string.ascii_lowercase
            elif label == 'Number':
                pool = template_string.digits
            elif label == 'Special':
                pool = template_string.punctuation
            elif label == 'Space':
                pool = ' '
            elif label == 'Total':
                pool = template_string.ascii_letters + template_string.digits + template_string.punctuation + ' '
            else:
                pool = label
            if is_expected == 0:  # must contain
                for character in pool:
                    self.z3solver.add(Contains(input_str, character))
                logger.debug('Must contain [%s]' % (pool))
            elif is_expected == 1:  # contain number of these
                func_list = []
                for character in pool:
                    func_list.append(Contains(input_str, character))  # concate z3 grammar as sequence
                self.z3solver.add(Or(func_list))
                logger.debug('Might contain [%s]' % (pool))
                if length > 1:
                    substr = random_sequence(pool, length)
                    if substr:
                        self.z3solver.add(Contains(input_str, substr))
                        logger.debug('Should contain %d character: %s' % (length, substr))
                    else:
                        logger.warn('cannt generate random substr from [%s] with %d long' % (pool, length))
            else:  # not contain
                for character in pool:
                    self.z3solver.add(Not(Contains(input_str, character)))
                logger.debug('Not contain %s' % (pool))
        except Exception as e:
            print(e)
            logger.warn('z3 solver error.')
            self.z3solver = None

    def __shorter(self, maxlength: int):
        if self.z3solver is None:
            return
        try:
            input_str = String('x')
            self.z3solver.add(Length(input_str) <= maxlength)
            logger.debug('length <= %d' % (maxlength))
        except Exception as e:
            print(e)
            logger.warn('z3 solver error.')
            self.z3solver = None

    def __longer(self, minlength: int):
        if self.z3solver is None:
            return
        try:
            input_str = String('x')
            self.z3solver.add(Length(input_str) >= minlength)
            logger.debug('length >= %d' % (minlength))
        except Exception as e:
            print(e)
            logger.warn('z3 solver error.')
            self.z3solver = None

    def __smaller(self, maxval: int):
        if self.z3solver is None:
            return
        try:
            value = Int('y')
            self.z3solver.add(value <= maxval)
            logger.debug('value <= %d' % (maxval))
        except Exception as e:
            print(e)
            logger.warn('z3 solver error.')
            self.z3solver = None

    def __bigger(self, minval: int):
        if self.z3solver is None:
            return
        try:
            value = Int('y')
            self.z3solver.add(value >= minval)
            logger.debug('value >= %d' % (minval))
        except Exception as e:
            print(e)
            logger.warn('z3 solver error.')
            self.z3solver = None

    def exclude_history(self, history: list):
        if self.z3solver is None:
            return
        try:
            y = Int('y')
            x = String('x')
            for old_input in history:
                if isinstance(old_input, int):
                    self.z3solver.add(y != old_input)
                elif isinstance(old_input, str):
                    self.z3solver.add(Not(x == StringVal(old_input)))
                else:
                    logger.error('Unknown type')
        except Exception as e:
            print(e)
            logger.warn('z3 solver error.')
            self.z3solver = None


def random_sequence(pool: str, length: int):
    result = ''
    if len(pool) == 0 or length == 0:
        return result
    while length > len(pool):
        length -= len(pool)
        result += ''.join(random.sample(pool, len(pool)))
    if length > 0:
        result += ''.join(random.sample(pool, length))
    return result
